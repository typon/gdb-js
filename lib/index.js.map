{"version":3,"sources":["webpack:///webpack/bootstrap cbe6b6b583a94753a0f9","webpack:///./src/index.js","webpack:///external \"debug\"","webpack:///./~/events/events.js","webpack:///external \"highland\"","webpack:///./src/error.js","webpack:///./src/thread.js","webpack:///./src/group.js","webpack:///./src/breakpoint.js","webpack:///./src/frame.js","webpack:///./src/variable.js","webpack:///./src/parsers/gdbmi.pegjs","webpack:///./src/scripts/base.py","webpack:///./src/scripts/exec.py","webpack:///./src/scripts/context.py","webpack:///./src/scripts/sources.py","webpack:///./src/scripts/group.py","webpack:///./src/scripts/thread.py","webpack:///./src/scripts/event.py","webpack:///./src/scripts/objfile.py"],"names":["debugOutput","debugCLIInput","debugMIInput","debugCLIResluts","debugMIResluts","debugEvents","toInt","str","parseInt","escape","script","replace","GDB","childProcess","_process","_queue","_lock","Promise","resolve","stream","stdout","map","chunk","toString","splitBy","tap","results","observe","filter","msg","type","zip","Object","assign","fork","state","each","data","cmd","reject","text","err","code","success","interpreter","commands","exec","compact","JSON","parse","includes","emit","consoleStream","logStream","targetStream","thread","event","reason","frame","file","fullname","line","status","breakpoint","bkptno","id","group","slice","pid","flatMap","match","_sync","scripts","s","_execMI","param","value","_set","_async","_execCMD","res","process","scope","kill","mapToThread","t","options","level","threads","_currentThread","_selectThread","_threadGroups","_currentThreadGroup","_selectThreadGroup","bkpts","BreakpointTable","body","result","bkpt","enabled","bpObj","number","func","push","pos","opt","bp","v","stack","f","files","pattern","groups","g","concat","index","indexOf","expr","src","_execMInor","executable","task","_preserveThread","then","_exec","name","stdin","write","binary","Thread","ThreadGroup","Breakpoint","Frame","Variable","_parseMI","GDBError","command","message","Error","Number","isInteger"],"mappings":"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2BAeOkF,I,EAAM;AACX,YAAKzG,KAAL,GAAa,KAAKA,KAAL,CAAW2G,IAAX,CAAgBF,IAAhB,EAAsBA,IAAtB,CAAb;AACA,cAAO,KAAKzG,KAAZ;AACD;;;yBA7tBc;AACb,cAAO,KAAKF,QAAZ;AACD;;;;;;SA8tBMF,G,GAAAA,G;SAAKqH,M;SAAQC,W;SAAaC,U;SACjCC,K;SAAOC,Q;SAAqBC,Q;;;;;;ACxkC9B,mC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAC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A;;AAEA;AACA,0CAAyC,QAAQ;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,oDAAoD;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,yBAAyB,EAAE;AAC1F,gEAA+D,yBAAyB,EAAE;AAC1F,gEAA+D,yBAAyB,EAAE;AAC1F,gEAA+D,yBAAyB,EAAE;AAC1F;;AAEA;AACA;;AAEA,oBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,+CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,+CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mBAAmB;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,+CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mBAAmB;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,+CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mBAAmB;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mBAAmB;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,oBAAoB;AAC5D;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,mBAAmB;AACvD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,wBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS,IAAI;;AAEb;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA,MAAK;AACL;AACA,mBAAkB,2CAA2C;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC,I;;;;;;ACt9CD,0aAAya,EAAE,EAAE,EAAE,EAAE,EAAE,iG;;;;;;ACAnb,siB;;;;;;ACAA,s9BAAq9B,oOAAoO,uG;;;;;;ACAzrC,yaAAwa,EAAE,+K;;;;;;ACA1a,0TAAyT,0CAA0C,8C;;;;;;ACAnW,0eAAye,2CAA2C,oC;;;;;;ACAphB,8JAA6J,EAAE,EAAE,EAAE,EAAE,EAAE,4D;;;;;;ACAvK,gP","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cbe6b6b583a94753a0f9","import createDebugger from 'debug'\nimport { EventEmitter } from 'events'\nimport _ from 'highland'\n\n// Custom error class.\nimport GDBError from './error.js'\n// Thread object class.\nimport Thread from './thread.js'\n// Thread group object class.\nimport ThreadGroup from './group.js'\n// Breakpoint object class.\nimport Breakpoint from './breakpoint.js'\n// Frame object class.\nimport Frame from './frame.js'\n// Variable object class.\nimport Variable from './variable.js'\n// Parser for the GDB/MI output syntax.\nimport { parse as parseMI } from './parsers/gdbmi.pegjs'\n// Base class for custom GDB commands.\nimport baseCommand from './scripts/base.py'\n// Command that executes CLI commands and returns them as a string.\nimport execCommand from './scripts/exec.py'\n// Command that lists all symbols (e.g. locals, globals) in the current context.\nimport contextCommand from './scripts/context.py'\n// Command that searches source files using regex.\nimport sourcesCommand from './scripts/sources.py'\n// Command that returns the current thread group.\nimport groupCommand from './scripts/group.py'\n// Command that returns the current thread.\nimport threadCommand from './scripts/thread.py'\n// Base handler for custom GDB events.\nimport baseEvent from './scripts/event.py'\n// Event that emits when new objfile is added.\nimport objfileEvent from './scripts/objfile.py'\n\n// Debug logging.\nlet debugOutput = createDebugger('gdb-js:output')\nlet debugCLIInput = createDebugger('gdb-js:input:cli')\nlet debugMIInput = createDebugger('gdb-js:input:mi')\nlet debugCLIResluts = createDebugger('gdb-js:results:cli')\nlet debugMIResluts = createDebugger('gdb-js:results:mi')\nlet debugEvents = createDebugger('gdb-js:events')\n\n/**\n * Converts string to integer.\n *\n * @param {string} str The input string.\n * @returns {number} The output integer.\n *\n * @ignore\n */\nfunction toInt (str) {\n  return parseInt(str, 10)\n}\n\n/**\n * Escapes symbols in python code so that we can send it using inline mode.\n *\n * @param {string} script The Python script.\n * @returns {string} The escaped python script.\n *\n * @ignore\n */\nfunction escape (script) {\n  return script.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r').replace(/\\t/g, '\\\\t').replace(/\"/g, '\\\\\"')\n}\n\n/**\n * Task to execute.\n *\n * @name Task\n * @function\n * @returns {Promise<any, GDBError>|any} Whatever.\n *\n * @ignore\n */\n\n/**\n * Class representing a GDB abstraction.\n *\n * @extends EventEmitter\n * @public\n */\nclass GDB extends EventEmitter {\n  /**\n   * Create a GDB wrapper.\n   *\n   * @param {object} childProcess A Node.js child process or just an\n   *   object with `stdin`, `stdout`, `stderr` properties that are Node.js streams.\n   *   If you're using GDB all-stop mode, then it should also have implementation of\n   *   `kill` method that is able to send signals (such as `SIGINT`).\n   */\n  constructor (childProcess) {\n    super()\n\n    this._process = childProcess\n    /**\n     * The main queue of commands sent to GDB.\n     *\n     * @ignore\n     */\n    this._queue = _()\n    /**\n     * The mutex to make simultaneous execution of public methods impossible.\n     *\n     * @ignore\n     */\n    this._lock = Promise.resolve()\n\n    let stream = _(this._process.stdout)\n      .map((chunk) => chunk.toString())\n      .splitBy(/\\r\\n|\\n/)\n      .tap(debugOutput)\n      .map(parseMI)\n\n    // Basically, we're just branching our stream to the messages that should\n    // be emitted and the results which we then zip with the sent commands.\n    // Results can be either result records or framed console records.\n\n    let results = stream.observe()\n      .filter((msg) => msg.type === 'result')\n      .zip(this._queue)\n      .map((msg) => Object.assign({}, msg[0], msg[1]))\n\n    results.fork()\n      .filter((msg) => msg.state === 'error')\n      .each((msg) => {\n        let { data, cmd, reject } = msg\n        let text = `Error while executing \"${cmd}\". ${data.msg}`\n        let err = new GDBError(cmd, text, toInt(data.code))\n        reject(err)\n      })\n\n    let success = results.fork()\n      .filter((msg) => msg.state !== 'error')\n\n    success.fork()\n      .filter((msg) => msg.interpreter === 'mi')\n      .tap((msg) => debugMIResluts(msg.data))\n      .each((msg) => { msg.resolve(msg.data) })\n\n    let commands = stream.observe()\n      .filter((msg) => msg.type === 'console')\n      // It's not possible for a command message to be split into multiple\n      // console records, so we can safely just regex every record.\n      .map((msg) => /<gdbjs:cmd:[a-z-]+ (.*?) [a-z-]+:cmd:gdbjs>/.exec(msg.data))\n      .compact()\n      .map((msg) => JSON.parse(msg[1]))\n      .tap(debugCLIResluts)\n\n    success.observe()\n      .filter((msg) => msg.interpreter === 'cli')\n      .zip(commands)\n      .each((msg) => { msg[0].resolve(msg[1]) })\n\n    // Emitting raw async records.\n\n    /**\n     * Raw output of GDB/MI notify records.\n     * Contains supplementary information that the client should handle.\n     * Please, see\n     * {@link https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Async-Records.html|the official GDB/MI documentation}.\n     *\n     * @event GDB#notify\n     * @type {object}\n     * @property {string} state The class of the notify record (e.g. `thread-created`).\n     * @property {object} data JSON representation of GDB/MI message.\n     */\n\n    /**\n     * Raw output of GDB/MI status records.\n     * Contains on-going status information about the progress of a slow operation.\n     *\n     * @event GDB#status\n     * @type {object}\n     * @property {string} state The class of the status record.\n     * @property {object} data JSON representation of GDB/MI message.\n     */\n\n    /**\n     * Raw output of GDB/MI exec records.\n     * Contains asynchronous state change on the target.\n     *\n     * @event GDB#exec\n     * @type {object}\n     * @property {string} state The class of the exec record (e.g. `stopped`).\n     * @property {object} data JSON representation of GDB/MI message.\n     */\n    stream.fork()\n      .filter((msg) => ['exec', 'notify', 'status'].includes(msg.type))\n      .each((msg) => { this.emit(msg.type, { state: msg.state, data: msg.data }) })\n\n    // Exposing streams of raw stream records.\n\n    /**\n     * Raw output of GDB/MI console records.\n     *\n     * @type {Readable<string>}\n     */\n    this.consoleStream = stream.observe()\n      .filter((msg) => msg.type === 'console')\n      .map((msg) => msg.data.replace(/<gdbjs:.*?:gdbjs>/g, ''))\n\n    /**\n     * Raw output of GDB/MI log records.\n     * The log stream contains debugging messages being produced by gdb's internals.\n     *\n     * @type {Readable<string>}\n     */\n    this.logStream = stream.observe()\n      .filter((msg) => msg.type === 'log')\n      .map((msg) => msg.data)\n\n    /**\n     * Raw output of GDB/MI target records.\n     * The target output stream contains any textual output from the running target.\n     * Please, note that it's currently impossible\n     * to distinguish the target and the MI output correctly due to a bug in GDB/MI. Thus,\n     * it's recommended to use `--tty` option with your GDB process.\n     *\n     * @type {Readable<string>}\n     */\n    this.targetStream = stream.observe()\n      .filter((msg) => msg.type === 'target')\n      .map((msg) => msg.data)\n\n    // Emitting defined events.\n\n    /**\n     * This event is emitted when target or one of its threads has stopped due to some reason.\n     * Note that `thread` property indicates the thread that caused the stop. In an all-stop mode\n     * all threads will be stopped.\n     *\n     * @event GDB#stopped\n     * @type {object}\n     * @property {string} reason The reason of why target has stopped (see\n     *   {@link https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Async-Records.html|the official GDB/MI documentation}) for more information.\n     * @property {Thread} [thread] The thread that caused the stop.\n     * @property {Breakpoint} [breakpoint] Breakpoint is provided if the reason is\n     *   `breakpoint-hit`.\n     */\n    stream.fork()\n      .filter((msg) => msg.type === 'exec' && msg.state === 'stopped')\n      .each((msg) => {\n        let { data } = msg\n        let thread = data['thread-id']\n        let event = { reason: data.reason }\n        if (thread) {\n          event.thread = new Thread(toInt(thread), {\n            frame: new Frame({\n              file: data.frame.fullname,\n              line: toInt(data.frame.line)\n            }),\n            status: 'stopped'\n          })\n        }\n        if (data.reason === 'breakpoint-hit') {\n          event.breakpoint = new Breakpoint(toInt(data.bkptno))\n        }\n\n        this.emit('stopped', event)\n      })\n\n    /**\n     * This event is emitted when target changes state to running.\n     *\n     * @event GDB#running\n     * @type {object}\n     * @property {Thread} [thread] The thread that has changed its state.\n     *   If it's not provided, all threads have changed their states.\n     */\n    stream.fork()\n      .filter((msg) => msg.type === 'exec' && msg.state === 'running')\n      .each((msg) => {\n        let { data } = msg\n        let thread = data['thread-id']\n        let event = {}\n        if (thread !== 'all') {\n          event.thread = new Thread(toInt(thread), { status: 'running' })\n        }\n\n        this.emit('running', event)\n      })\n\n    /**\n     * This event is emitted when new thread spawns.\n     *\n     * @event GDB#thread-created\n     * @type {Thread}\n     */\n\n    /**\n     * This event is emitted when thread exits.\n     *\n     * @event GDB#thread-exited\n     * @type {Thread}\n     */\n    stream.fork()\n      .filter((msg) => msg.type === 'notify' &&\n        ['thread-created', 'thread-exited'].includes(msg.state))\n      .each((msg) => {\n        let { state, data } = msg\n\n        this.emit(state, new Thread(toInt(data.id), {\n          // GDB/MI stores group id as `i<id>` string.\n          group: new ThreadGroup(toInt(data['group-id'].slice(1)))\n        }))\n      })\n\n    /**\n     * This event is emitted when thread group starts.\n     *\n     * @event GDB#thread-group-started\n     * @type {ThreadGroup}\n     */\n\n    /**\n     * This event is emitted when thread group exits.\n     *\n     * @event GDB#thread-group-exited\n     * @type {ThreadGroup}\n     */\n    stream.fork()\n      .filter((msg) => msg.type === 'notify' &&\n        ['thread-group-started', 'thread-group-exited'].includes(msg.state))\n      .each((msg) => {\n        let { state, data } = msg\n\n        this.emit(state, new ThreadGroup(toInt(data.id.slice(1)), {\n          pid: data.pid ? toInt(data.pid) : null\n        }))\n      })\n\n    /**\n     * This event is emitted with the full path to executable\n     * when the new objfile is added.\n     *\n     * @event GDB#new-objfile\n     * @type {string}\n     */\n    stream.fork()\n      .filter((msg) => msg.type === 'console')\n      .flatMap((msg) => msg.data.match(/<gdbjs:event:.*?:event:gdbjs>/g) || [])\n      .map((msg) => /<gdbjs:event:([a-z-]+) (.*?) [a-z-]+:event:gdbjs>/g.exec(msg))\n      .tap((msg) => debugEvents(msg[1], msg[2]))\n      .each((msg) => { this.emit(msg[1], msg[2]) })\n  }\n\n  // Public methods.\n  // Note, that it's really important to not call public methods\n  // inside other public methods, because it may cause blocking!\n\n  /**\n   * Get the child process object.\n   *\n   * @type {object}\n   * @readonly\n   */\n  get process () {\n    return this._process\n  }\n\n  /**\n   * Extend GDB CLI interface with some useful commands that are\n   * necessary for executing some methods of this GDB wrapper\n   * (e.g. {@link GDB#context|context}, {@link GDB#execCLI|execCLI}).\n   * It also enables custom actions (like {@link GDB#new-objfile|`new-objfile` event}).\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  init () {\n    return this._sync(async () => {\n      let scripts = [baseCommand, baseEvent, execCommand, contextCommand,\n        sourcesCommand, groupCommand, threadCommand, objfileEvent]\n\n      for (let s of scripts) {\n        await this._execMI(`-interpreter-exec console \"python\\\\n${escape(s)}\"`)\n      }\n    })\n  }\n\n  /**\n   * Set internal GDB variable.\n   *\n   * @param {string} param The name of a GDB variable.\n   * @param {string} value The value of a GDB variable.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  set (param, value) {\n    return this._sync(() => this._set(param, value))\n  }\n\n  /**\n   * Enable the `detach-on-fork` option which will automatically\n   * attach GDB to any of forked processes. Please, note that it makes\n   * sense only for systems that support `fork` and `vfork` calls.\n   * It won't work for Windows, for example.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  attachOnFork () {\n    return this._sync(() => this._set('detach-on-fork', 'off'))\n  }\n\n  /**\n   * Enable async and non-stop modes in GDB. This mode is *highly* recommended!\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  enableAsync () {\n    return this._sync(async () => {\n      try {\n        await this._set('mi-async', 'on')\n      } catch (e) {\n        // For gdb <= 7.7 (which not support `mi-async`).\n        await this._set('target-async', 'on')\n      }\n      await this._set('non-stop', 'on')\n      this._async = true\n    })\n  }\n\n  /**\n   * Attach a new target (inferior) to GDB.\n   *\n   * @param {number} pid The process id or to attach.\n   *\n   * @returns {Promise<ThreadGroup, GDBError>} A promise that resolves/rejects\n   *   with the added thread group.\n   */\n  attach (pid) {\n    return this._sync(() => async () => {\n      let res = await this._execCMD('exec add-inferior')\n      let id = toInt(/Added inferior (\\d+)/.exec(res)[1])\n      let group = new ThreadGroup(id)\n      await this._execMI('-target-attach ' + pid, group)\n      return group\n    })\n  }\n\n  /**\n   * Detache a target (inferior) from GDB.\n   *\n   * @param {ThreadGroup|number} process The process id or the thread group to detach.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  detach (process) {\n    return this._sync(() => this._execMI('-target-detach ' +\n      (process instanceof ThreadGroup ? 'i' + process.id : process)))\n  }\n\n  /**\n   * Interrupt the target. In all-stop mode and in non-stop mode without arguments\n   * it interrupts all threads. In non-stop mode it can interrupt only specific thread or\n   * a thread group.\n   *\n   * @param {Thread|ThreadGroup} [scope] The thread or thread-group to interrupt.\n   *   If this parameter is omitted, it will interrupt all threads.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  interrupt (scope) {\n    return this._sync(() => {\n      if (!this._async) {\n        this._process.kill('SIGINT')\n      } else {\n        return this._execMI(scope\n          ? '-exec-interrupt' : '-exec-interrupt --all', scope)\n      }\n    })\n  }\n\n  /**\n   * Get the information about all the threads or about specific threads.\n   *\n   * @param {Thread|ThreadGroup} [scope] Get information about threads of the specific\n   *   thread group or even about the specific thread (if it doesn't have enough information\n   *   or it's outdated). If this parameter is absent, then information about all\n   *   threads is returned.\n   *\n   * @returns {Promise<Thread[]|Thread, GDBError>} A promise that resolves with an array\n   *   of threads or a single thread.\n   */\n  threads (scope) {\n    return this._sync(async () => {\n      let mapToThread = (t) => {\n        let options = { status: t.state }\n        if (t.frame) {\n          options.frame = new Frame({\n            file: t.frame.fullname,\n            line: toInt(t.frame.line),\n            level: toInt(t.frame.level)\n          })\n        }\n\n        return new Thread(toInt(t.id), options)\n      }\n\n      if (scope instanceof Thread) {\n        let { threads } = await this._execMI('-thread-info ' + scope.id)\n        return mapToThread(threads[0])\n      } else if (scope instanceof ThreadGroup) {\n        let { threads } = await this._execMI(`-list-thread-groups i${scope.id}`)\n        return threads.map(mapToThread)\n      } else {\n        let { threads } = await this._execMI('-thread-info')\n        return threads.map(mapToThread)\n      }\n    })\n  }\n\n  /**\n   * Get the current thread.\n   *\n   * @returns {Promise<Thread, GDBError>} A promise that resolves with a thread.\n   */\n  currentThread () {\n    return this._sync(() => this._currentThread())\n  }\n\n  /**\n   * Although you can pass scope to commands, you can also explicitly change\n   * the context of command execution. Sometimes it might be slightly faster.\n   *\n   * @param {Thread} thread The thread that should be selected.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  selectThread (thread) {\n    return this._sync(() => this._selectThread(thread))\n  }\n\n  /**\n   * Get thread groups.\n   *\n   * @returns {Promise<ThreadGroup[], GDBError>} A promise that resolves with\n   *   an array thread groups.\n   */\n  threadGroups () {\n    return this._sync(() => this._threadGroups())\n  }\n\n  /**\n   * Get the current thread group.\n   *\n   * @returns {Promise<ThreadGroup, GDBError>} A promise that resolves with the thread group.\n   */\n  currentThreadGroup () {\n    return this._sync(() => this._currentThreadGroup())\n  }\n\n  /**\n   * Although you can pass scope to commands, you can also explicitly change\n   * the context of command execution. Sometimes it might be slightly faster.\n   *\n   * @param {ThreadGroup} group The thread group that should be selected.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  selectThreadGroup (group) {\n    return this._sync(() => this._selectThreadGroup(group))\n  }\n  /**\n   * Lists all breakpoints.\n   *\n   * @returns {Promise<Breakpoints, GDBError>} A promise that resolves with list of breakpoints.\n   **/\n\n  getBreaks () {\n    return this._sync(async () => {\n      //let { bkpt } = await this._execMI(`-break-insert main.c:bar`)\n      let bkpts = await this._execMI(`-break-list`)\n      bkpts = bkpts.BreakpointTable.body\n      let result = []\n      let thread = ''\n      for (let bkpt of bkpts)  {\n          bkpt = bkpt.value\n          let enabled = bkpt.enabled == 'y' ? true: false\n          let bpObj = new Breakpoint(toInt(bkpt.number), {\n                        file: bkpt.fullname,\n                        line: toInt(bkpt.line),\n                        func: bkpt.func,\n                        thread: thread,\n                        enabled: enabled \n                      })\n        result.push(bpObj)\n      }\n      return result\n\n    })\n  }\n\n  /**\n   * Insert a breakpoint at the specified position.\n   *\n   * @param {string} file The full name or just a file name.\n   * @param {number|string} pos The function name or a line number.\n   * @param {Thread} [thread] The thread where breakpoint should be set.\n   *   If this field is absent, breakpoint applies to all threads.\n   *\n   * @returns {Promise<Breakpoint, GDBError>} A promise that resolves with a breakpoint.\n   */\n  addBreak (file, pos, thread) {\n    return this._sync(async () => {\n      let opt = thread ? '-p ' + thread.id : ''\n      let { bkpt } = await this._execMI(`-break-insert ${opt} ${file}:${pos}`)\n      return new Breakpoint(toInt(bkpt.number), {\n        file: bkpt.fullname,\n        line: toInt(bkpt.line),\n        func: bkpt.func,\n        thread\n      })\n    })\n  }\n\n  /**\n   * Removes a specific breakpoint.\n   *\n   * @param {Breakpoint} [bp] The breakpoint.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  removeBreak (bp) {\n    return this._sync(() => this._execMI('-break-delete ' + bp.id))\n  }\n\n  /**\n   * Step in.\n   *\n   * @param {Thread|ThreadGroup} [scope] The thread or thread group where\n   *   the stepping should be done.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  stepIn (scope) {\n    return this._sync(() => this._execMI('-exec-step', scope))\n  }\n\n  /**\n   * Step out.\n   *\n   * @param {Thread|ThreadGroup} [scope] The thread or thread group where\n   *   the stepping should be done.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  stepOut (scope) {\n    return this._sync(() => this._execMI('-exec-finish', scope))\n  }\n\n  /**\n   * Execute to the next line.\n   *\n   * @param {Thread|ThreadGroup} [scope] The thread or thread group where\n   *   the stepping should be done.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  next (scope) {\n    return this._sync(() => this._execMI('-exec-next', scope))\n  }\n\n  /**\n   * Run the current target.\n   *\n   * @param {ThreadGroup} [group] The thread group to run.\n   *   If this parameter is omitted, current thread group will be run.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  run (group) {\n    // XXX: seems like MI command `-exec-run` has a bug that makes it\n    // run in the foreground mode (although the opposite is stated in the docs).\n    // This can cause blocking even in `target-async` mode.\n    return this._sync(() => this._async ? this._execCMD('exec run&', group)\n      : this._execMI('-exec-run', group))\n  }\n\n  /**\n   * Continue execution.\n   *\n   * @param {Thread|ThreadGroup} [scope] The thread or thread group that should be continued.\n   *   If this parameter is omitted, all threads are continued.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  proceed (scope) {\n    return this._sync(() => this._execMI(scope\n      ? '-exec-continue' : '-exec-continue --all', scope))\n  }\n\n  /**\n   * List all symbols in the current context (i.e. all global, static, local\n   * variables and constants in the current file).\n   *\n   * @param {Thread} [thread] The thread from which the context should be taken.\n   *\n   * @returns {Promise<Variable[], GDBError>} A promise that resolves with\n   *   an array of variables.\n   */\n  context (thread) {\n    return this._sync(async () => {\n      let res = await this._execCMD('context', thread)\n      return res.map((v) => new Variable(v))\n    })\n  }\n\n  /**\n   * Get the callstack.\n   *\n   * @param {Thread} [thread] The thread from which the callstack should be taken.\n   *\n   * @returns {Promise<Frame[], GDBError>} A promise that resolves with an array of frames.\n   */\n  callstack (thread) {\n    return this._sync(async () => {\n      let { stack } = await this._execMI('-stack-list-frames', thread)\n      return stack.map((f) => new Frame({\n        file: f.value.fullname,\n        line: toInt(f.value.line),\n        level: toInt(f.value.level)\n      }))\n    })\n  }\n\n  /**\n   * Get list of source files or a subset of source files that match\n   * the regular expression. Please, note that it doesn't return sources.\n   *\n   * @example\n   * let headers = await gdb.sourceFiles({ pattern: '\\.h$' })\n   *\n   * @param {object} [options] The options object.\n   * @param {ThreadGroup} [options.group] The thread group (i.e. target) for\n   *   which source files are needed. If this parameter is absent, then\n   *   source files are returned for all targets.\n   * @param {string} [options.pattern] The regular expression (see\n   *   {@link https://docs.python.org/2/library/re.html|Python regex syntax}).\n   *   This option is useful when the project has a lot of files so that\n   *   it's not desirable to send them all in one chunk along the wire.\n   *\n   * @returns {Promise<string[], GDBError>} A promise that resolves with\n   *   an array of source files.\n   */\n  sourceFiles (options = {}) {\n    return this._sync(async () => {\n      let files = []\n      let group = options.group\n      let pattern = options.pattern || ''\n      let cmd = 'sources ' + pattern\n\n      if (group) {\n        files = await this._execCMD(cmd, group)\n      } else {\n        let groups = await this._threadGroups()\n        for (let g of groups) {\n          files = files.concat(await this._execCMD(cmd, g))\n        }\n        files = files.filter((f, index) => files.indexOf(f) === index)\n      }\n\n      return files\n    })\n  }\n\n  /**\n   * Evaluate a GDB expression.\n   *\n   * @param {string} expr The expression to evaluate.\n   * @param {Thread|ThreadGroup} [scope] The thread or thread group where\n   *   the expression should be evaluated.\n   *\n   * @returns {Promise<string, GDBError>} A promise that resolves with the result of expression.\n   */\n  evaluate (expr, scope) {\n    return this._sync(async () => {\n      let res = await this._execMI('-data-evaluate-expression ' + expr, scope)\n      return res.value\n    })\n  }\n\n  /**\n   * Exit GDB.\n   *\n   * @returns {Promise<undefined, GDBError>} A promise that resolves/rejects\n   *   after completion of a GDB command.\n   */\n  exit () {\n    return this._sync(() => this._execMI('-gdb-exit'))\n  }\n\n  /**\n   * Execute a custom python script and get the results of its excecution.\n   * If your python script is asynchronous and you're interested in its output, you should\n   * either define a new event (refer to the *Extending* section in the main page) or\n   * read the {@link GDB#consoleStream|console stream}. Here's the example below.\n   *\n   * By the way, with this method you can define your own CLI commands and then call\n   * them via {@link GDB#execCLI|execCLI} method. For more examples, refer to the *Extending*\n   * section on the main page and read\n   * {@link https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html|official GDB Python API}\n   * and {@link https://sourceware.org/gdb/wiki/PythonGdbTutorial|PythonGdbTutorial}.\n   *\n   * @example\n   * let script = `\n   * import gdb\n   * import threading\n   *\n   *\n   * def foo():\n   *     sys.stdout.write('bar')\n   *     sys.stdout.flush()\n   *\n   * timer = threading.Timer(5.0, foo)\n   * timer.start()\n   * `\n   * gdb.consoleStream.on('data', (str) => {\n   *   if (str === 'bar') console.log('yep')\n   * })\n   * await gdb.execPy(script)\n   *\n   * @param {string} src The python script.\n   * @param {Thread} [thread] The thread where the script should be executed.\n   *\n   * @returns {Promise<string, GDBError>} A promise that resolves with the output of\n   *   python script execution.\n   */\n  execPy (src, scope) {\n    return this._sync(() => this._execCMD(`exec python\\\\n${escape(src)}`, scope))\n  }\n\n  /**\n   * Execute a CLI command.\n   *\n   * @param {string} cmd The CLI command.\n   * @param {Thread|ThreadGroup} [scope] The thread where the command should be executed.\n   *\n   * @returns {Promise<string, GDBError>} A promise that resolves with\n   *   the result of command execution.\n   */\n  execCLI (cmd, scope) {\n    return this._sync(() => this._execCMD(`exec ${cmd}`, scope))\n  }\n\n  /**\n   * Execute a custom defined command. Refer to the *Extending* section on the main\n   * page of the documentation.\n   *\n   * @param {string} cmd The name of the command.\n   * @param {Thread|ThreadGroup} [scope] The thread or thread-group where\n   *   the command should be executed. If this parameter is omitted,\n   *   it executes in the current thread.\n   *\n   * @returns {Promise<object, GDBError>} A promise that resolves with\n   *   the JSON representation of the result of command execution.\n   */\n  execCMD (cmd, scope) {\n    return this._sync(() => this._execCMD(cmd, scope))\n  }\n\n  /**\n   * Execute a MI command.\n   *\n   * @param {string} cmd The MI command.\n   * @param {Thread|ThreadGroup} [scope] The thread or thread-group where\n   *   the command should be executed. If this parameter is omitted,\n   *   it executes in the current thread.\n   *\n   * @returns {Promise<object, GDBError>} A promise that resolves with\n   *   the JSON representation of the result of command execution.\n   */\n  execMI (cmd, scope) {\n    return this._sync(() => this._execMI(cmd, scope))\n  }\n\n  /**\n   * Execute a MI with no expectation of return value.\n   *\n   * @param {string} cmd The MI command.\n   * @param {Thread|ThreadGroup} [scope] The thread or thread-group where\n   *   the command should be executed. If this parameter is omitted,\n   *   it executes in the current thread.\n   *\n   * @returns Nothing.\n   */\n  execMInor (cmd, scope) {\n    return this._execMInor(cmd, scope)\n  }\n\n  // Private methods\n  // Note that it's necessary to not call public methods and {@link GDB#_sync}\n  // method in these methods since it may cause blocking.\n\n  /**\n   * Internal method for setting values. See {@link GDB#set}.\n   *\n   * @ignore\n   */\n  async _set (param, value) {\n    await this._execMI(`-gdb-set ${param} ${value}`)\n  }\n\n  /**\n   * Internal method for getting the current thread. See {@link GDB#currentThread}.\n   *\n   * @ignore\n   */\n  async _currentThread () {\n    let { id, group } = await this._execCMD('thread')\n    return id ? new Thread(id, { group }) : null\n  }\n\n  /**\n   * Internal method for getting the current thread group. See {@link GDB#currentThreadGroup}.\n   *\n   * @ignore\n   */\n  async _currentThreadGroup () {\n    let { id, pid } = await this._execCMD('group')\n    return new ThreadGroup(id, { pid })\n  }\n\n  /**\n   * Internal method for selecting the thread groups. See {@link GDB#selectThread}.\n   *\n   * @ignore\n   */\n  async _selectThread (thread) {\n    await this._execMI('-thread-select ' + thread.id)\n  }\n\n  /**\n   * Internal method for selecting the thread group. See {@link GDB#selectThreadGroup}.\n   *\n   * @ignore\n   */\n  async _selectThreadGroup (group) {\n    await this._execCMD('exec inferior ' + group.id)\n  }\n\n  /**\n   * Internal method for getting thread groups. See {@link GDB#threadGroups}.\n   *\n   * @ignore\n   */\n  async _threadGroups () {\n    let { groups } = await this._execMI('-list-thread-groups')\n    return groups.map((g) => new ThreadGroup(toInt(g.id.slice(1)), {\n      pid: toInt(g.pid),\n      executable: g.executable\n    }))\n  }\n\n  /**\n   * Helps to restore the current thread between operations and avoid side effect.\n   *\n   * @param {Task} [task] The task to execute.\n   *\n   * @returns {Promise<any, GDBError>} A promise that resolves with task results.\n   *\n   * @ignore\n   */\n  async _preserveThread (task) {\n    let thread = await this._currentThread()\n    let res = await task()\n    if (thread) await this._selectThread(thread)\n    return res\n  }\n\n  /**\n   * Internal method for calling defined Python commands. See {@link GDB#execCMD}.\n   *\n   * @ignore\n   */\n  _execCMD (cmd, scope) {\n    if (scope instanceof Thread) {\n      return this._preserveThread(() =>\n        this._selectThread(scope).then(() => this._exec(cmd, 'cli')))\n    } else if (scope instanceof ThreadGroup) {\n      return this._preserveThread(() =>\n        this._selectThreadGroup(scope).then(() => this._exec(cmd, 'cli')))\n    } else {\n      return this._exec(cmd, 'cli')\n    }\n  }\n\n  /**\n   * Internal method for calling MI commands. See {@link GDB#execMI}.\n   *\n   * @ignore\n   */\n  _execMI (cmd, scope) {\n    let [, name, options] = /([^ ]+)( .*|)/.exec(cmd)\n\n    if (scope instanceof Thread) {\n      return this._exec(`${name} --thread ${scope.id} ${options}`, 'mi')\n    } else if (scope instanceof ThreadGroup) {\n      // `--thread-group` option changes thread.\n      return this._preserveThread(() =>\n        this._exec(`${name} --thread-group i${scope.id} ${options}`, 'mi'))\n    } else {\n      return this._exec(cmd, 'mi')\n    }\n  }\n  \n  /**\n   * Internal method for calling MI nor commands.\n   *\n   * @ignore\n   */\n  _execMInor (cmd, scope) {\n    let [, name, options] = /([^ ]+)( .*|)/.exec(cmd)\n\n    if (scope instanceof Thread) {\n      return this._exec(`${name} --thread ${scope.id} ${options}`, 'minor')\n    } else if (scope instanceof ThreadGroup) {\n      // `--thread-group` option changes thread.\n      return this._preserveThread(() =>\n        this._exec(`${name} --thread-group i${scope.id} ${options}`, 'minor'))\n    } else {\n      return this._exec(cmd, 'minor')\n    }\n  }\n\n  /**\n   * Internal method that executes a MI command and add it to the queue where it\n   * waits for the results of execution.\n   *\n   * @param {string} cmd The command (eaither a MI or a defined Python command).\n   * @param {string} interpreter The interpreter that should execute the command.\n   *\n   * @returns {Promise<object, GDBError>} A promise that resolves with\n   *   the JSON representation of the result of command execution.\n   *\n   * @ignore\n   */\n  _exec (cmd, interpreter) {\n    if (interpreter === 'mi') {\n      debugMIInput(cmd)\n    } else if (interpreter === 'minor') {\n      debugMIInput(cmd)\n    } else {\n      debugCLIInput(`gdbjs-${cmd}`)\n      cmd = `-interpreter-exec console \"gdbjs-${cmd}\"`\n    }\n\n    this._process.stdin.write(cmd + '\\n', { binary: true })\n\n    if (interpreter == 'minor') {\n        return true;\n    } else {\n        return new Promise((resolve, reject) => {\n          this._queue.write({ cmd, interpreter, resolve, reject })\n        })\n    }\n  }\n\n  /**\n   * This routine makes it impossible to run multiple punlic methods\n   * simultaneously. Why this matter? It's really important for public\n   * methods to not interfere with each other, because they can change\n   * the state of GDB during execution. They should be atomic,\n   * meaning that calling them simultaneously should produce the same\n   * results as calling them in order. One way to ensure that is to block\n   * execution of public methods until other methods complete.\n   *\n   * @param {Task} task The task to execute.\n   *\n   * @returns {Promise<any, GDBError>} A promise that resolves with task results.\n   *\n   * @ignore\n   */\n  _sync (task) {\n    this._lock = this._lock.then(task, task)\n    return this._lock\n  }\n}\n\nexport { GDB, Thread, ThreadGroup, Breakpoint,\n  Frame, Variable, parseMI as _parseMI }\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 1\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 2\n// module chunks = 0","module.exports = require(\"highland\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"highland\"\n// module id = 3\n// module chunks = 0","/**\n * Class representing an internal GDB error.\n *\n * @extends Error\n */\nclass GDBError extends Error {\n  /**\n   * Create a GDBError.\n   *\n   * @param {string} cmd Command that led to this error.\n   * @param {string} msg Error message.\n   * @param {number} [code] Error code.\n   *\n   * @private\n   */\n  constructor (cmd, msg, code) {\n    super(msg)\n\n    this.name = 'GDBError'\n    /**\n     * Command that led to this error.\n     *\n     * @type {string}\n     **/\n    this.command = cmd\n    /**\n     * Error message.\n     *\n     * @type {string}\n     **/\n    this.message = msg\n    /**\n     * Error code.\n     *\n     * @type {?number}\n     **/\n    this.code = code\n  }\n}\n\nexport default GDBError\n\n\n\n// WEBPACK FOOTER //\n// ./src/error.js","/**\n * Class representing a thread.\n */\nclass Thread {\n  /**\n   * Create a thread object.\n   * Usually you don't need to create it yourself unless\n   * you're doing some low-level stuff.\n   *\n   * @param {number} id The internal GDB ID of a thread.\n   * @param {object} [options] The options object.\n   * @param {string} [options.status] The thread status (e.g. `stopped`).\n   * @param {ThreadGroup} [options.group] The thread group.\n   * @param {Frame} [options.frame] The frame where thread is currently on.\n   */\n  constructor (id, options = {}) {\n    /**\n     * The internal GDB ID of a thread.\n     *\n     * @type {number}\n     */\n    this.id = id\n\n    /**\n     * The thread status (e.g. `stopped`).\n     *\n     * @type {?string}\n     */\n    this.status = options.status || null\n\n    /**\n     * The thread group.\n     *\n     * @type {?ThreadGroup}\n     */\n    this.group = options.group || null\n\n    /**\n     * The frame where thread is currently on.\n     *\n     * @type {?Frame}\n     */\n    this.frame = options.frame || null\n  }\n}\n\nexport default Thread\n\n\n\n// WEBPACK FOOTER //\n// ./src/thread.js","/**\n * Class representing a thread group (aka target, aka inferior).\n */\nclass ThreadGroup {\n  /**\n   * Create a thread group object.\n   * Usually you don't need to create it yourself unless\n   * you're doing some low-level stuff.\n   *\n   * @param {number} id The internal GDB ID of a thread group.\n   * @param {object} [options] The options object.\n   * @param {string} [options.executable] The executable of target.\n   * @param {number} [options.pid] The PID of the thread-group.\n   */\n  constructor (id, options = {}) {\n    /**\n     * The internal GDB ID of a thread group.\n     *\n     * @type {number}\n     */\n    this.id = id\n\n    /**\n     * The executable of target.\n     *\n     * @type {?string}\n     */\n    this.executable = options.executable || null\n\n    /**\n     * The PID of the thread-group.\n     *\n     * @type {?number}\n     */\n    this.pid = Number.isInteger(options.pid)\n      ? options.pid : null\n  }\n}\n\nexport default ThreadGroup\n\n\n\n// WEBPACK FOOTER //\n// ./src/group.js","/**\n * Class representing a breakpoint.\n */\nclass Breakpoint {\n  /**\n   * Create a breakpoint object.\n   * Usually you don't need to create it yourself unless\n   * you're doing some low-level stuff.\n   *\n   * @param {number} id The internal GDB ID of a breakpoint.\n   * @param {object} [options] The options object.\n   * @param {string} [options.file] The full path to a file in which breakpoint appears.\n   * @param {number} [options.line] The line number at which the breakpoint appears.\n   * @param {string} [options.func] The function in which the breakpoint appears.\n   * @param {enabled} [options.enabled] Bool indiciating whether this breakpoint is enabled.\n   * @param {Thread} [options.thread] The thread for thread-specific breakpoints.\n   */\n  constructor (id, options = {}) {\n    /**\n     * The internal GDB ID of a breakpoint.\n     *\n     * @type {number}\n     */\n    this.id = id\n\n    /**\n     * The full path to a file in which breakpoint appears.\n     *\n     * @type {?string}\n     */\n    this.file = options.file || null\n\n    /**\n     * The line number at which the breakpoint appears.\n     *\n     * @type {?number}\n     */\n    this.line = options.line || null\n\n    /**\n     * The function in which the breakpoint appears.\n     *\n     * @type {?string}\n     */\n    this.func = options.func || null\n\n    /**\n     * The thread for thread-specific breakpoints.\n     *\n     * @type {?Thread}\n     */\n    this.thread = options.thread || null\n\n    /**\n     * The thread for thread-specific breakpoints.\n     *\n     * @type {?Thread}\n     */\n    this.enabled = options.enabled || null\n\n  }\n}\n\nexport default Breakpoint\n\n\n\n// WEBPACK FOOTER //\n// ./src/breakpoint.js","/**\n * Class representing a frame.\n */\nclass Frame {\n  /**\n   * Create a frame object.\n   *\n   * @param {object} options The options object.\n   * @param {string} options.file The full path to a file.\n   * @param {number} options.line The line number.\n   * @param {number} [options.level] The level of stack frame.\n   */\n  constructor (options = {}) {\n    /**\n     * The full path to a file.\n     *\n     * @type {string}\n     */\n    this.file = options.file\n\n    /**\n     * The line number.\n     *\n     * @type {number}\n     */\n    this.line = options.line\n\n    /**\n     * The level of stack frame.\n     *\n     * @type {?number}\n     */\n    this.level = Number.isInteger(options.level)\n      ? options.level : null\n  }\n}\n\nexport default Frame\n\n\n\n// WEBPACK FOOTER //\n// ./src/frame.js","/**\n * Class representing a variable.\n */\nclass Variable {\n  /**\n   * Create a variable object.\n   * Usually you don't need to create it yourself.\n   *\n   * @param {object} options The options object.\n   * @param {string} options.name The name of the variable.\n   * @param {string} options.type The type of the variable.\n   * @param {string} options.scope The scope of the variable.\n   * @param {string} options.value The value of the variable.\n   */\n  constructor (options = {}) {\n    /**\n     * The name of the variable.\n     *\n     * @type {string}\n     */\n    this.name = options.name\n\n    /**\n     * The type of the variable.\n     *\n     * @type {string}\n     */\n    this.type = options.type\n\n    /**\n     * The scope of the variable.\n     *\n     * @type {string}\n     */\n    this.scope = options.scope\n\n    /**\n     * The value of the variable.\n     *\n     * @type {string}\n     */\n    this.value = options.value\n  }\n}\n\nexport default Variable\n\n\n\n// WEBPACK FOOTER //\n// ./src/variable.js","module.exports = (function() {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { Line: peg$parseLine },\n        peg$startRuleFunction  = peg$parseLine,\n\n        peg$c0 = \"(gdb) \",\n        peg$c1 = { type: \"literal\", value: \"(gdb) \", description: \"\\\"(gdb) \\\"\" },\n        peg$c2 = function() { return { type: 'prompt' } },\n        peg$c3 = { type: \"any\", description: \"any character\" },\n        peg$c4 = function() { return { type: 'target', data: text() } },\n        peg$c5 = \"^\",\n        peg$c6 = { type: \"literal\", value: \"^\", description: \"\\\"^\\\"\" },\n        peg$c7 = function(state, results) {\n              return { type: 'result', state, data: makeResults(results) }\n            },\n        peg$c8 = \"*\",\n        peg$c9 = { type: \"literal\", value: \"*\", description: \"\\\"*\\\"\" },\n        peg$c10 = function(obj) {\n              return { type: 'exec', state: obj.state, data: obj.data }\n            },\n        peg$c11 = \"+\",\n        peg$c12 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\n        peg$c13 = function(obj) {\n              return { type: 'status', state: obj.state, data: obj.data }\n            },\n        peg$c14 = \"=\",\n        peg$c15 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c16 = function(obj) {\n              return { type: 'notify', state: obj.state, data: obj.data }\n            },\n        peg$c17 = \"~\",\n        peg$c18 = { type: \"literal\", value: \"~\", description: \"\\\"~\\\"\" },\n        peg$c19 = function(data) { return { type: 'console', data } },\n        peg$c20 = \"@\",\n        peg$c21 = { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n        peg$c22 = function(data) { return { type: 'target', data } },\n        peg$c23 = \"&\",\n        peg$c24 = { type: \"literal\", value: \"&\", description: \"\\\"&\\\"\" },\n        peg$c25 = function(data) { return { type: 'log', data } },\n        peg$c26 = function(state, results) {\n              return { state, data: makeResults(results) }\n            },\n        peg$c27 = \",\",\n        peg$c28 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c29 = function(result) { return result },\n        peg$c30 = function(value) { return value },\n        peg$c31 = \"\",\n        peg$c32 = function(name, value) { return { name, value } },\n        peg$c33 = \"{}\",\n        peg$c34 = { type: \"literal\", value: \"{}\", description: \"\\\"{}\\\"\" },\n        peg$c35 = function() { return {}; },\n        peg$c36 = \"{\",\n        peg$c37 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n        peg$c38 = \"}\",\n        peg$c39 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n        peg$c40 = function(result, results) {\n              return makeResults([result, ...results])\n            },\n        peg$c41 = \"[]\",\n        peg$c42 = { type: \"literal\", value: \"[]\", description: \"\\\"[]\\\"\" },\n        peg$c43 = function() { return []; },\n        peg$c44 = \"[\",\n        peg$c45 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c46 = \"]\",\n        peg$c47 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c48 = function(value, values) { return [value, ...values] },\n        peg$c49 = function(result, results) { return [result, ...results] },\n        peg$c50 = \"done\",\n        peg$c51 = { type: \"literal\", value: \"done\", description: \"\\\"done\\\"\" },\n        peg$c52 = \"running\",\n        peg$c53 = { type: \"literal\", value: \"running\", description: \"\\\"running\\\"\" },\n        peg$c54 = \"connected\",\n        peg$c55 = { type: \"literal\", value: \"connected\", description: \"\\\"connected\\\"\" },\n        peg$c56 = \"error\",\n        peg$c57 = { type: \"literal\", value: \"error\", description: \"\\\"error\\\"\" },\n        peg$c58 = \"exit\",\n        peg$c59 = { type: \"literal\", value: \"exit\", description: \"\\\"exit\\\"\" },\n        peg$c60 = \"stopped\",\n        peg$c61 = { type: \"literal\", value: \"stopped\", description: \"\\\"stopped\\\"\" },\n        peg$c62 = { type: \"other\", description: \"c-string\" },\n        peg$c63 = \"\\\"\",\n        peg$c64 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c65 = function(chars) { return decodeURIComponent(chars.join('')) },\n        peg$c66 = { type: \"other\", description: \"char\" },\n        peg$c67 = /^[^%\\\\\"]/,\n        peg$c68 = { type: \"class\", value: \"[^%\\\\\\\\\\\\\\\"]\", description: \"[^%\\\\\\\\\\\\\\\"]\" },\n        peg$c69 = \"%\",\n        peg$c70 = { type: \"literal\", value: \"%\", description: \"\\\"%\\\"\" },\n        peg$c71 = function() { return '%25' },\n        peg$c72 = \"\\\\\",\n        peg$c73 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\n        peg$c74 = /^[0-7]/,\n        peg$c75 = { type: \"class\", value: \"[0-7]\", description: \"[0-7]\" },\n        peg$c76 = function(seq) { return '%' + parseInt(seq.join(''), 8).toString(16) },\n        peg$c77 = function(seq) { return seq },\n        peg$c78 = { type: \"other\", description: \"escaped\" },\n        peg$c79 = \"b\",\n        peg$c80 = { type: \"literal\", value: \"b\", description: \"\\\"b\\\"\" },\n        peg$c81 = function() { return '\\b' },\n        peg$c82 = \"f\",\n        peg$c83 = { type: \"literal\", value: \"f\", description: \"\\\"f\\\"\" },\n        peg$c84 = function() { return '\\f' },\n        peg$c85 = \"n\",\n        peg$c86 = { type: \"literal\", value: \"n\", description: \"\\\"n\\\"\" },\n        peg$c87 = function() { return '\\n' },\n        peg$c88 = \"r\",\n        peg$c89 = { type: \"literal\", value: \"r\", description: \"\\\"r\\\"\" },\n        peg$c90 = function() { return '\\r' },\n        peg$c91 = \"t\",\n        peg$c92 = { type: \"literal\", value: \"t\", description: \"\\\"t\\\"\" },\n        peg$c93 = function() { return '\\t' },\n        peg$c94 = { type: \"other\", description: \"string\" },\n        peg$c95 = /^[A-z\\-_]/,\n        peg$c96 = { type: \"class\", value: \"[A-z-_]\", description: \"[A-z-_]\" },\n        peg$c97 = function() { return text() },\n        peg$c98 = { type: \"other\", description: \"token\" },\n        peg$c99 = /^[0-9]/,\n        peg$c100 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c101 = function() { return parseInt(text(), 10) },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseLine() {\n      var s0, s1, s2;\n\n      s0 = peg$parseAsyncRecord();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseStreamRecord();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseResultRecord();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 6) === peg$c0) {\n              s1 = peg$c0;\n              peg$currPos += 6;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c1); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c2();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = [];\n              if (input.length > peg$currPos) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c3); }\n              }\n              while (s2 !== peg$FAILED) {\n                s1.push(s2);\n                if (input.length > peg$currPos) {\n                  s2 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c3); }\n                }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c4();\n              }\n              s0 = s1;\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseAsyncRecord() {\n      var s0;\n\n      s0 = peg$parseExecAsyncOutput();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseStatusAsyncOutput();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseNotifyAsyncOutput();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseStreamRecord() {\n      var s0;\n\n      s0 = peg$parseConsoleStreamOutput();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseTargetStreamOutput();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseLogStreamOutput();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseResultRecord() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseToken();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 94) {\n          s2 = peg$c5;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseResultClass();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseResultsList();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s3, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseExecAsyncOutput() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseToken();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s2 = peg$c8;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c9); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseAsyncOutput();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c10(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseStatusAsyncOutput() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseToken();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s2 = peg$c11;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseAsyncOutput();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseNotifyAsyncOutput() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseToken();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c14;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseAsyncOutput();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseConsoleStreamOutput() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 126) {\n        s1 = peg$c17;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseConst();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseTargetStreamOutput() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 64) {\n        s1 = peg$c20;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseConst();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseLogStreamOutput() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 38) {\n        s1 = peg$c23;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseConst();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseAsyncOutput() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseAsyncClass();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseResultsList();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c26(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseResultsList() {\n      var s0, s1, s2, s3;\n\n      s0 = [];\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c27;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseResult();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c29(s3);\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c27;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseResult();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c29(s3);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseValuesList() {\n      var s0, s1, s2, s3;\n\n      s0 = [];\n      s1 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s2 = peg$c27;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseValue();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s1;\n          s2 = peg$c30(s3);\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c27;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseValue();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s2 = peg$c30(s3);\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseResult() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseString();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s2 = peg$c14;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c15); }\n        }\n        if (s2 === peg$FAILED) {\n          s2 = peg$c31;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseValue();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c32(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseValue() {\n      var s0;\n\n      s0 = peg$parseConst();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseTuple();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseList();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseTuple() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c33) {\n        s1 = peg$c33;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c35();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c36;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseResult();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseResultsList();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s4 = peg$c38;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c39); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c40(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseList() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c41) {\n        s1 = peg$c41;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c43();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s1 = peg$c44;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c45); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseValue();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseValuesList();\n            if (s3 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s4 = peg$c46;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c47); }\n              }\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c48(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c44;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c45); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseResult();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseResultsList();\n              if (s3 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 93) {\n                  s4 = peg$c46;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c47); }\n                }\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c49(s2, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseResultClass() {\n      var s0;\n\n      if (input.substr(peg$currPos, 4) === peg$c50) {\n        s0 = peg$c50;\n        peg$currPos += 4;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c51); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c52) {\n          s0 = peg$c52;\n          peg$currPos += 7;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c53); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 9) === peg$c54) {\n            s0 = peg$c54;\n            peg$currPos += 9;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c55); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c56) {\n              s0 = peg$c56;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c57); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4) === peg$c58) {\n                s0 = peg$c58;\n                peg$currPos += 4;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c59); }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseAsyncClass() {\n      var s0;\n\n      if (input.substr(peg$currPos, 7) === peg$c60) {\n        s0 = peg$c60;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseString();\n      }\n\n      return s0;\n    }\n\n    function peg$parseConst() {\n      var s0, s1, s2, s3;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c63;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseChar();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseChar();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c63;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c64); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c65(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c62); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseChar() {\n      var s0, s1, s2, s3, s4, s5;\n\n      peg$silentFails++;\n      if (peg$c67.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c68); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 37) {\n          s1 = peg$c69;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c70); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c71();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s1 = peg$c72;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            if (peg$c74.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c75); }\n            }\n            if (s3 !== peg$FAILED) {\n              if (peg$c74.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c75); }\n              }\n              if (s4 !== peg$FAILED) {\n                if (peg$c74.test(input.charAt(peg$currPos))) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c75); }\n                }\n                if (s5 !== peg$FAILED) {\n                  s3 = [s3, s4, s5];\n                  s2 = s3;\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c76(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s1 = peg$c72;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c73); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseEscaped();\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c77(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c66); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseEscaped() {\n      var s0, s1;\n\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s0 = peg$c63;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s0 = peg$c72;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c73); }\n        }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 98) {\n          s1 = peg$c79;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c80); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c81();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 102) {\n            s1 = peg$c82;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c83); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c84();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 110) {\n              s1 = peg$c85;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c86); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c87();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 114) {\n                s1 = peg$c88;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c89); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c90();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 116) {\n                  s1 = peg$c91;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c92); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c93();\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c78); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseString() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c95.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c96); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c95.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c96); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c97();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c94); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseToken() {\n      var s0, s1, s2;\n\n      peg$silentFails++;\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c99.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c100); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c99.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c100); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c101();\n      }\n      s0 = s1;\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\n      }\n\n      return s0;\n    }\n\n\n      function makeResults (arr) {\n        // XXX: sometimes GDB/MI results don't have name (e.g.\n        // `=breakpoint-modified` when `addr` property is `<MULTIPLE>`).\n        // Below code helps to turn such records into the array.\n\n        for (let i = 0; i < arr.length; i++) {\n          if (!arr[i].name) arr[i].name = arr[i - 1] ? arr[i - 1].name : 'unnamed';\n        }\n\n        let res = arr.reduce((acc, r) => {\n          if (!acc[r.name]) acc[r.name] = []\n          acc[r.name].push(r.value)\n          return acc\n        }, {})\n\n        for (let name in res) {\n          if (res[name].length === 1) res[name] = res[name][0]\n        }\n\n        return res\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/parsers/gdbmi.pegjs\n// module id = 10\n// module chunks = 0","module.exports = \"import gdb\\nimport sys\\nimport json\\n\\n\\nclass BaseCommand(gdb.Command):\\n    \\\"\\\"\\\"Base class for custom GDB commands.\\\"\\\"\\\"\\n\\n    def __init__(self, name):\\n        super(BaseCommand, self).__init__(\\\"gdbjs-\\\" + name, gdb.COMMAND_USER)\\n        self.name = name\\n\\n    def invoke(self, arg, from_tty):\\n        res = json.dumps(self.action(arg, from_tty), ensure_ascii=False)\\n        msg = '<gdbjs:cmd:{0} {1} {0}:cmd:gdbjs>'.format(self.name, res)\\n        sys.stdout.write(msg)\\n        sys.stdout.flush()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/base.py\n// module id = 11\n// module chunks = 0","module.exports = \"import gdb\\nimport sys\\nimport re\\n\\n\\nclass ExecCommand(BaseCommand):\\n    \\\"\\\"\\\"Executes a CLI command and prints results.\\\"\\\"\\\"\\n\\n    def __init__(self):\\n        super(ExecCommand, self).__init__(\\\"exec\\\")\\n\\n    def action(self, arg, from_tty):\\n        res = gdb.execute(arg, False, True)\\n        # Results of CLI execution might accidently contain events.\\n        events = re.findall(\\\"<gdbjs:event:.*?:event:gdbjs>\\\", res)\\n        for e in events: sys.stdout.write(e)\\n        return res\\n\\ngdbjsExec = ExecCommand()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/exec.py\n// module id = 12\n// module chunks = 0","module.exports = \"import gdb\\nfrom builtins import str\\n\\n\\nclass ContextCommand(BaseCommand):\\n    \\\"\\\"\\\"Lists all symbols in the current context.\\\"\\\"\\\"\\n\\n    def __init__(self):\\n        super(ContextCommand, self).__init__(\\\"context\\\")\\n\\n    def action(self, arg, from_tty):\\n        frame = gdb.selected_frame()\\n        block = frame.block()\\n        names = set()\\n        variables = []\\n        while block:\\n            for symbol in block:\\n                name = symbol.name\\n                if (name not in names) and (symbol.is_argument or\\n                   symbol.is_variable or symbol.is_function or\\n                   symbol.is_constant):\\n                    scope = \\\"global\\\" if block.is_global else \\\\\\n                            \\\"static\\\" if block.is_static else \\\\\\n                            \\\"argument\\\" if symbol.is_argument else \\\\\\n                            \\\"local\\\"\\n                    names.add(name)\\n                    variables.append({\\n                        \\\"name\\\": symbol.name,\\n                        \\\"value\\\": str(symbol.value(frame)),\\n                        \\\"type\\\": str(symbol.type),\\n                        \\\"scope\\\": scope\\n                    })\\n            block = block.superblock\\n        return variables\\n\\ngdbjsContext = ContextCommand()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/context.py\n// module id = 13\n// module chunks = 0","module.exports = \"import gdb\\nimport re\\n\\n\\nclass SourcesCommand(BaseCommand):\\n    \\\"\\\"\\\"Search for source files using regex.\\\"\\\"\\\"\\n\\n    def __init__(self):\\n        super(SourcesCommand, self).__init__(\\\"sources\\\")\\n\\n    def action(self, arg, from_tty):\\n        info = gdb.execute(\\\"info sources\\\", False, True)\\n        # XXX: not sure, whether there is a better way.\\n        info = re.sub(\\\"Reading symbols .*?\\\\.{3}done\\\\.\\\", \\\"\\\", info)\\n        files = re.findall(r\\\"([/\\\\\\\\].*?)[,\\\\n]\\\", info)\\n        return [f for f in files if re.search(arg, f)]\\n\\ngdbjsSources = SourcesCommand()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/sources.py\n// module id = 14\n// module chunks = 0","module.exports = \"import gdb\\n\\n\\nclass ThreadGroupCommand(BaseCommand):\\n    \\\"\\\"\\\"Returns the current thread group.\\\"\\\"\\\"\\n\\n    def __init__(self):\\n        super(ThreadGroupCommand, self).__init__(\\\"group\\\")\\n\\n    def action(self, arg, from_tty):\\n        inferior = gdb.selected_inferior()\\n        return { 'id': inferior.num, 'pid': inferior.pid }\\n\\ngdbjsThreadGroup = ThreadGroupCommand()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/group.py\n// module id = 15\n// module chunks = 0","module.exports = \"import gdb\\n\\n\\nclass ThreadCommand(BaseCommand):\\n    \\\"\\\"\\\"Returns the current thread.\\\"\\\"\\\"\\n\\n    def __init__(self):\\n        super(ThreadCommand, self).__init__(\\\"thread\\\")\\n\\n    def action(self, arg, from_tty):\\n        thread = gdb.selected_thread()\\n        # `global_num` was introduced in GDB 7.11\\n        num = getattr(thread, 'global_num', None) or thread.num if thread else None\\n        inferior = gdbjsThreadGroup.action(arg, from_tty)\\n        return { \\\"id\\\": num or None, \\\"group\\\": inferior }\\n\\ngdbjsThread = ThreadCommand()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/thread.py\n// module id = 16\n// module chunks = 0","module.exports = \"import sys\\n\\n\\ndef base_event_handler(name, msg):\\n    \\\"\\\"\\\"Base handler for custom events.\\\"\\\"\\\"\\n\\n    sys.stdout.write('<gdbjs:event:{0} {1} {0}:event:gdbjs>'.format(name, msg))\\n    sys.stdout.flush()\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/event.py\n// module id = 17\n// module chunks = 0","module.exports = \"import gdb\\n\\n\\ndef new_objfile_handler(event):\\n    \\\"\\\"\\\"Handle the new objfile event.\\\"\\\"\\\"\\n\\n    base_event_handler('new-objfile', event.new_objfile.filename)\\n\\ngdb.events.new_objfile.connect(new_objfile_handler)\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/scripts/objfile.py\n// module id = 18\n// module chunks = 0"],"sourceRoot":""}